@namespace Theatre_TimeLine.Components
@using Theatre_TimeLine.Models
@using Theatre_TimeLine.Contracts
@using System.Linq
@inherits LayoutComponentBase

@if (ShouldRenderTimeSeparator())
{
    <MudTimelineItem Class="@Class">
        <MudText>@GetRoadDatePart()</MudText>
    </MudTimelineItem>
}

@foreach (var item in this.GetAddresses())
{
    switch (item.AddressType)
    {
        case AddressType.VideoMedia:
            <VideoMediaAddress Address="item" />
            break;
        default:
            <NotificationAddress Address="item" />
        break;
    }
}

@code {

    private int measurement = 24;

    [Parameter]
    public IRoadToThere Road { get; set; } = new RoadToThere();

    [Parameter]
    public int BlockIndex { get; set; }

    [Parameter]
    public string? Style { get; set; }

    [Parameter]
    public string? Class { get; set; }

    protected override Task OnParametersSetAsync()
    {
        if (Road != null)
        {
            switch (Road.RoadScope)
            {
                case RoadScope.Week:
                    measurement = 1;
                    break;
                case RoadScope.Month:
                    measurement = 4;
                    break;
                case RoadScope.Year:
                    measurement = 30;
                    break;
                default:
                    measurement = 24;
                    break;
            }
        }

        return base.OnParametersSetAsync();
    }

    private string GetRoadDatePart()
    {
        DateTime resultingDateTime = GetBlockTime();

        // Convert the result of the point in time to a string.
        switch (Road?.RoadScope)
        {
            case RoadScope.Day:
                return resultingDateTime.ToString("t");
            case RoadScope.Week:
                return resultingDateTime.ToString("MMM dd, yyyy");
            case RoadScope.Month:
                return resultingDateTime.ToString("MMM dd, yyyy");
            case RoadScope.Year:
                return resultingDateTime.ToString("MMM yyyy");
            default:
                return string.Empty;
        }
    }

    private DateTime GetBlockTime()
    {
        if (Road is null)
        {
            return DateTime.Now;
        }

        if (!Road.StartTime.HasValue)
        {
            return DateTime.Now;
        }

        DateTime startDate = Road?.StartTime.Value ?? DateTime.Now;
        DateTime resultingDateTime = startDate.AddHours(BlockIndex);

        // Convert block index to a point in time.
        switch (Road?.RoadScope)
        {
            case RoadScope.Week:
            case RoadScope.Month:
            case RoadScope.Year:
                resultingDateTime = startDate.AddDays(BlockIndex);
                break;
        }

        return resultingDateTime;
    }

    private bool ShouldRenderTimeSeparator()
    {
        return BlockIndex == 0
        || BlockIndex == Road.Duration;
    }

    private IEnumerable<IAddress> GetAddresses()
    {
        if (Road is null)
        {
            return Enumerable.Empty<IAddress>();
        }

        if (!Road.StartTime.HasValue)
        {
            return Enumerable.Empty<IAddress>();
        }

        DateTime blockRange = Road.RoadScope == RoadScope.Day
            ? Road.StartTime.Value.AddHours(BlockIndex)
            : Road.StartTime.Value.AddDays(BlockIndex);

        if (blockRange > Road.EndTime)
        {
            return Enumerable.Empty<IAddress>();
        }

        return Road.Addresses
            .Where(x => x.Location <= blockRange.AddHours(24).AddSeconds(-1) && x.Location >= blockRange)
            .OrderByDescending(x => x.Location);
    }
}
