@using Theatre_TimeLine.Services
@using Theatre_Timeline.Contracts
@using Theatre_TimeLine.Models
@inject ITenantManagerService TenantManagerService
@implements IRoadToThereManager

@page "/TenantManagement/{Tenant?}"

<div id="existing-tenants">
    @foreach (ITenantContainer container in TenantManagerService.GetWebApps())
    {
        <MudCard Class="card" >
            <MudCardHeader Class="card card-header">@container.TenantName</MudCardHeader>
            <MudCardContent>
                <p>@container.Description</p>
                <code>@container.TenantId</code>
            </MudCardContent>
            <MudCardActions>
                <MudButtonGroup>
                    <MudButton OnClick="() =>
{
    this.Tenant = container.TenantId.ToString();
    ButtonClicked();
}">@buttonText.Item2</MudButton>
                    <MudMenu Icon="@Icons.Material.Filled.ArrowDropDown" Style="align-self: auto;">
                        @foreach (string action in tenantActions)
                        {
                            <MudMenuItem OnClick="() => SetButtonText(Array.IndexOf(tenantActions, action))">@action</MudMenuItem>
                        }
                    </MudMenu>
                </MudButtonGroup>
            </MudCardActions>
        </MudCard>
        <br />
    }
</div>

<br />
<div id="create-tenant">
    <p>Place holder for a form.</p>
    <button class="btn btn-primary" @onclick="CreateTenant">Create Tenant</button>
</div>

@code {

    private static readonly string[] tenantActions =
    {
        "Create Road",
        "Remove Tenant"
    };

    private Tuple<int, string> buttonText = Tuple.Create(0, tenantActions[0]);

    [Parameter]
    public string? Tenant { get; set; }  = string.Empty;

    protected async override Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();
    }

    private void CreateTenant()
    {
        TenantManagerService.CreateTenant(new TenantContainer()
        {
             TenantId = Guid.NewGuid(),
             Description = "Test description",
             TenantName = "Test Name"
        });

        this.StateHasChanged();
    }

    private void RemoveTenant()
    {
        if (TryGetTenantContainer(out ITenantContainer? tenantContainer) && tenantContainer != null)
        {
            TenantManagerService.RemoveTenant(tenantContainer.TenantId);
        }
    }

    private bool TryGetTenantContainer(out ITenantContainer? tenantContainer)
    {
        tenantContainer = null;
        if (!string.IsNullOrEmpty(this.Tenant) && Guid.TryParse(this.Tenant, out Guid result))
        {
            tenantContainer = TenantManagerService.GetTenant(result);
        }

        return tenantContainer != null;
    }

    private void SetButtonText(int id)
    {
        buttonText = Tuple.Create(id, tenantActions[id]);
    }

    public void CreateRoad()
    {
        RoadToThere roadToThere = new RoadToThere()
            {
                RoadId = Guid.NewGuid(),
                TenantId = string.IsNullOrEmpty(this.Tenant) ? Guid.Empty : Guid.Parse(this.Tenant)
            };
        this.SaveRoad(roadToThere);
    }

    public void SaveRoad(RoadToThere roadToThere) => TenantManagerService.SaveRoad(roadToThere);

    public void RemoveRoad(Guid roadId) => TenantManagerService.RemoveRoad(roadId);

    public IRoadToThere GetRoad(Guid roadId) => TenantManagerService.GetRoad(roadId);

    private void ButtonClicked()
    {
        switch (buttonText.Item1)
        {
            case 0:
                CreateRoad();
                break;
            case 1:
                RemoveTenant();
                break;
        }
    }
}
